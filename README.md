# scala-test
Написать свой `foldLeft` через хвостовую рекурсию.
Это сделать можно на любом языке, если язык не умеет в функции, то обычно оборачивают в объект
например в джаве до 8 версии было так
```
class Function1 {
  execute(arg1) {
    тут код
  }
}
```
делаешь `new Function()` и ее можно распихивать везде

Написать через `fold`:
1. написать `sum(List[Int]): Int`
```
sum(List(1,2,3)) = 6
```
2. написать `map(f: A => B, List[A]): List[B]`
```
map(a => a.toString, List(1,2,3)) = List(“1”, “2", “3”)
```
3.  `concat(List[List[A]]): List[A]` - берет на вход лист листов и возвращает плоский лист
например
```
concat(List(List(1,2),List(3,4))) = List(1,2,3,4)
```
4. `takeWhile(pred: A => Bool, list: List[A]): List[A]` - берет на вход функцию-предикат и лист, возвращает лист, полученный проходом листа слева до первого элемента, не удовлетворяющему предикату
```
takeWhile(a => a < 5, List(2,4,6,7)) = List(2,4)
```
